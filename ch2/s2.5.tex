\documentclass{article}
\author{Abraham Levkoy}
\title{SICP exercises, section 2.4}

\usepackage{mystyle}

\begin{document}
\maketitle

\section{Exercise 2.77}
\begin{quote}
    Louis Reasoner tries to evaluate the expression \texttt{(magnitude z)} where
    \texttt{z} is the object shown in Figure 2.24. To his surprise, instead of
    the answer 5 he gets an error message from \texttt{apply-generic}, saying
    there is no method for the operation \texttt{magnitude} on the types
    \texttt{(complex)}. He shows this interaction to Alyssa P. Hacker, who says
    ``The problem is that the complex-number selectors were never defined for
    \texttt{complex} numbers, just for \texttt{polar} and \texttt{rectangular}
    numbers. All you have to do to make this work is add the following to the
    \texttt{complex} package:''
    \begin{lstlisting}
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
    \end{lstlisting}

    Describe in detail why this works. As an example, trace through all the
    procedures called in evaluating the expression \texttt{(magnitude z)} where
    \texttt{z} is the object shown in Figure 2.24. In particular, how many times
    is \texttt{apply-generic} invoked? What procedure is dispatched to in each
    case?
\end{quote}

The object shown in Figure 2.24 could be expressed as
\begin{lstlisting}
('complex . ('rectangular . (3 . 4)))
\end{lstlisting}

The procedures called in evaluating \texttt{(magnitude z)} in the corrected
system:
\begin{enumerate}
    \item \texttt{(apply-generic 'magnitude z)}: First application of
        \texttt{apply-generic}
    \item \texttt{(map type-tag z)}: Sets \texttt{type-tags} to
        \texttt{('complex)}
    \item \texttt{(get 'magnitude ('complex))}: This is what fails before the
        fix.
    \item \texttt{(apply magnitude ('rectangular . (3 . 4)))}: This is the
        generic \texttt{magnitude} defined by the complex package.
    \item \texttt{(apply-generic 'magnitude ('rectangular . (3 . 4)))}: Second
        application of \texttt{apply-generic}
    \item \texttt{(map type-tag ('rectangular . (3 . 4)))}: Sets
        \texttt{type-tags} to \texttt{('rectangular)}
    \item \texttt{get 'magnitude ('rectangular)}
    \item \texttt{(apply magnitude (3 . 4))}: This is the \texttt{magnitude}
        function from the rectangular package.
    \item \texttt{(sqrt (+ (square 3) (square 4)))}
\end{enumerate}

The function \texttt{magnitude} is being used at the level of abstraction at
which multiple types of numbers are defined. However, as it has been used so
far, it only really makes sense for complex numbers, and it is defined at that
level of abstraction. Packages are installed to provide implementations of
\texttt{magnitude} for multiple representations of complex numbers, but the
assumption that \texttt{magnitude} will be applied to complex numbers is
implicit. The definition of \texttt{z} makes that assumption explicit by adding
a \texttt{'complex} tag.

Alyssa's fix works by raising the complex-number primitives to the level of
abstraction at which multiple types of numbers are defined. When one of the
generic complex-number selectors is called with a \texttt{'complex}-tagged
argument, the outer tag is removed and the same \texttt{magnitude} is called
again on the contents of the argument, now exposing the tag indicating the
representation of complex numbers in use. Because there are two layers of tags,
\texttt{apply-generic} must be called twice to find the real implementation.

\section{Exercise 2.78}
\begin{quote}
    The internal procedures in the \texttt{scheme-number} package are
    essentially nothing more than calls to the primitive procedures \texttt{+},
    \texttt{-}, etc. It was not possible to use the primitives of the language
    directly because our type-tag system requires that each data object have a
    type attached to it. In fact, however, all Lisp implementations do have a
    type system, which they use internally. Primitive predicates such as
    \texttt{symbol?} and \texttt{number?} determine whether data objects have
    particular types. Modify the definitions of \texttt{type-tag},
    \texttt{contents}, and \texttt{attach-tag} from 2.4.2 so that our generic
    system takes advantage of Scheme's internal type system. That is to say,
    the system should work as before except that ordinary numbers should be
    represented simply as Scheme numbers rather than as pairs whose car is the
    symbol scheme-number.
\end{quote}

\lstinputlisting[firstline=186,lastline=201]{ch2/ex2.78.scm}

\section{Exercise 2.79}
\begin{quote}
    Define a generic equality predicate \texttt{equ?} that tests the equality
    of two numbers, and install it in the generic arithmetic package. This
    operation should work for ordinary numbers, rational numbers, and complex
    numbers.
\end{quote}

\lstinputlisting[firstline=235,lastline=267]{ch2/ex2.78.scm}

\section{Exercise 2.80}
\begin{quote}
    Define a generic predicate \texttt{=zero?} that tests if its argument is
    zero, and install it in the generic arithmetic package. This operation
    should work for ordinary numbers, rational numbers, and complex numbers.
\end{quote}

\lstinputlisting[firstline=299,lastline=309]{ch2/ex2.78.scm}

\section{Exercise 2.81}
\begin{quote}
    Louis Reasoner has noticed that \texttt{apply-generic} may try to coerce
    the arguments to each other's type even if they already have the same type.
    Therefore, he reasons, we need to put procedures in the coercion table to
    coerce arguments of each type to their own type. For example, in addition
    to the \texttt{scheme-number->complex} coercion shown above, he would do:

    \begin{lstlisting}
(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)

(put-coercion 'scheme-number 'scheme-number
              scheme-number->scheme-number)

(put-coercion 'complex 'complex
              complex->complex)
    \end{lstlisting}

    \begin{enumerate}
        \item With Louis's coercion procedures installed, what happens if
            \texttt{apply-generic} is called with two arguments of type
            \texttt{scheme-number} or two arguments of type \texttt{complex}
            for an operation that is not found in the table for those types?
            For example, assume that we've defined a generic exponentiation
            operation:

            \begin{lstlisting}
(define (exp x y)
  (apply-generic 'exp x y))
            \end{lstlisting}

            and have put a procedure for exponentiation in the Scheme-number
            package but not in any other package:

            \begin{lstlisting}
;; following added to Scheme-number package
(put 'exp
'(scheme-number scheme-number)
(lambda (x y)
(tag (expt x y))))
; using primitive expt
            \end{lstlisting}

            What happens if we call \texttt{exp} with two complex numbers as
            arguments?
        \item Is Louis correct that something had to be done about coercion
            with arguments of the same type, or does \texttt{apply-generic} work
            correctly as is?
        \item Modify \texttt{apply-generic} so that it doesnâ€™t try coercion if
            the two arguments have the same type.
    \end{enumerate}
\end{quote}

\begin{enumerate}
    \item When Louis' procedures are installed, and \texttt{apply-generic} is
        called with two \texttt{complex} arguments for an operation that is not
        defined for \texttt{complex} arguments, \texttt{apply-generic} will
        recurse infinitely. When it can't find a procedure for the supplied
        arguments, it will look for a coercion to convert the first argument to
        the type of the second, and it will find \texttt{complex->complex}.
        \texttt{apply-generic} will perform the coercion and call itself
        recursively. However, because the types of the arguments have not
        changed, the exact same thing will happen as the previous time, ad
        infinitum.
    \item \texttt{apply-generic} works correctly as is. If a procedure is
        already defined for two arguments of a certain type,
        \texttt{apply-generic} won't look for coercions at all, so it won't
        fail to find a conversion from \texttt{complex} to \texttt{complex}
        unless it was going to fail to find a procedure anyway.

        There are some weaknesses in the way that \texttt{apply-generic} looks
        for coercions. It assumes that, if a procedure is defined, it will be
        defined for two arguments of the same type, so it always attempts to
        convert one argument to the type of the other. If a procedure were
        defined for two \texttt{complex} arguments but not for two
        \texttt{scheme-number} arguments, \texttt{apply-generic} would not be
        able to produce a result for two \texttt{scheme-number} arguments, even
        though each argument can be coerced into \texttt{complex}.

        These limitations seem acceptable for a package dealing with various
        arithmetic operations, where the number types are related hierarchially,
        and it is expected for efficiency reasons that each type of number will
        have its own implementation of the applicable procedures. However, one
        could imagine that code size might be reduced by implementing all
        operations in terms of \texttt{complex} and converting all arguments to
        that. \texttt{apply-generic}, as written, would not support this.
    \item \lstinputlisting[firstline=249,lastline=284]{ch2/ex2.81.scm}
        I find the amount of repitition here somewhat galling, but at least
        using what I've learned so far, Scheme's capacity for terse error
        handling seems limited.
\end{enumerate}

\section{Exercise 2.82}
\begin{quote}
    Show how to generalize \texttt{apply-generic} to handle coercion in the
    general case of multiple arguments. One strategy is to attempt to coerce
    all the arguments to the type of the first argument, then to the type of
    the second argument, and so on. Give an example of a situation where this
    strategy (and likewise the two-argument version given above) is not
    sufficiently general. (Hint: Consider the case where there are some
    suitable mixed-type operations present in the table that will not be
    tried.)
\end{quote}

This is a version of \texttt{apply-generic} using the method described above:
\lstinputlisting[firstline=233,lastline=270]{ch2/ex2.82.scm}

This method will not work for sets of arguments where not all arguments can be
coerced to the type of any one argument, but all can be coerced to some other
type that is not present in the argument list. Consider, for example, adding two
numbers, one real and one imaginary. Neither can be coerced to the type of the
other, but both can be coerced to \texttt{'complex}, and addition is well
defined for complex numbers. However, this version of \texttt{apply-generic}
cannot perform this operation, because it can't find the right set of coercions.

\end{document}
