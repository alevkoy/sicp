\documentclass{article}
\author{Abraham Levkoy}
\title{SICP exercises, section 2.2}

\usepackage{mystyle}

\begin{document}
\maketitle

\section{Exercise 2.17}
\begin{quote}
    Define a procedure \texttt{last-pair} that returns the list that contains
    only the last element of a given (nonempty) list:
    \begin{lstlisting}
(last-pair (list 23 72 149 34))
(34)
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=3,lastline=6]{ch2/ex2.17.scm}

\section{Exercise 2.18}
\begin{quote}
    Define a procedure reverse that takes a list as argument and returns a list
    of the same elements in reverse order:
    \begin{lstlisting}
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=3,lastline=9]{ch2/ex2.18.scm}

Somewhat atypically, this was much easier (for me, at least) to define as an
iterative process than as a recursive process. The iterative process builds the
result up from the end using \texttt{cons}. The only recursive implementation
that I came up with starts from the beginning of the resulting list, so it
needs to traverse the entire list that it already built on every recursive
invocation, which I did using the previously defined \texttt{append} procedure.

\section{Exercise 2.19}
\begin{quote}
    [Long discussion of using \texttt{cc} with multiple lists of coin
    denominations.]

    Define the procedures \texttt{first-denomination},
    \texttt{except-first-denomination} and \texttt{no-more?} in terms of
    primitive operations on list structures. Does the order of the list
    \texttt{coin-values} affect the answer produced by \texttt{cc}? Why or why
    not?
\end{quote}

\lstinputlisting[firstline=20,lastline=27]{ch2/ex2.19.scm}

The order of \texttt{coin-values} does not affect the answer produced. It just
affects the order in which the possible combinations are explored. At each level
of the recursion, there are still a branch in which one coin is excluded and a
branch in which the amount to be matched is decreased by the value of the
current coin. As long as the recursion continues to the full depth in which all
coins have been considered, all possible combinations will be explored and
evaluated.

\section{Exercise 2.20}
\begin{quote}
    \ldots[W]rite a procedure \texttt{same-parity} that takes one or more
    integers and returns a list of all the arguments that have the same
    even-odd parity as the first argument. For example,
    \begin{lstlisting}
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)

(same-parity 2 3 4 5 6 7)
(2 4 6)
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=3,lastline=19]{ch2/ex2.20.scm}

This produces a recursive process, whereas I'd prefer an iterative one.
However, it allows the resulting list to be built up one element at a time
without traversing to the end to add each element. An iterative process that
considered successive elements of the input list, starting at the head, would
require repeated traversal of the output list to get the elements in the correct
order. This would involve a recursive component and probably more copying of
data.

\section{Exercise 2.21}
\begin{quote}
    The procedure \texttt{square-list} takes a list of numbers as argument and
    returns a list of the squares of those numbers.
    \begin{lstlisting}
(square-list (list 1 2 3 4))
(1 4 9 16)
    \end{lstlisting}
    Here are two different definitions of \texttt{square-list}. Complete both
    of them by filling in the missing expressions:
    \begin{lstlisting}
(define (square-list items)
  (if (null? items)
      nil
      (cons <??> <??>)))

(define (square-list items)
  (map <??> <??>))
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=5,lastline=9]{ch2/ex2.21.scm}
\lstinputlisting[firstline=14,lastline=16]{ch2/ex2.21.scm}

\section{Exercise 2.22}
\begin{quote}
    Louis Reasoner tries to rewrite the first \texttt{square-list} procedure of
    Exercise 2.21 so that it evolves an iterative process:
    \begin{lstlisting}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
    \end{lstlisting}
    Unfortunately, defining \texttt{square-list} this way produces the answer
    list in the reverse order of the one desired. Why?
\end{quote}

He iterates through the input list forward, that is from head to tail, but he
builds the output list from tail to head. Because of this, the head of the
input is transformed into the tail of the output, and so on.

\begin{quote}
    Louis then tries to fix his bug by interchanging the arguments to cons:
    \begin{lstlisting}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square
                     (car things))))))
  (iter items nil))
    \end{lstlisting}
This doesnâ€™t work either. Explain.
\end{quote}

This gets the output in basically the right order, but the structure is wrong. A
flat list is a sequence of pairs in which the \texttt{cdr} of each pair points
to the next pair, and the last \texttt{cdr} points to \texttt{nil}. By switching
the order of the arguments to \texttt{cons}, this code creates a pair in which
the \texttt{car} is a compound object, and the \texttt{cdr} is a bare integer.
The overall structure produced is a tree that is tited toward the left as
opposed to one tilted toward the right.

\end{document}
