\documentclass{article}
\author{Abraham Levkoy}
\title{SICP exercises, section 2.2}

\usepackage{mystyle}

\begin{document}
\maketitle

\section{Exercise 2.17}
\begin{quote}
    Define a procedure \texttt{last-pair} that returns the list that contains
    only the last element of a given (nonempty) list:
    \begin{lstlisting}
(last-pair (list 23 72 149 34))
(34)
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=3,lastline=6]{ch2/ex2.17.scm}

\section{Exercise 2.18}
\begin{quote}
    Define a procedure reverse that takes a list as argument and returns a list
    of the same elements in reverse order:
    \begin{lstlisting}
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=3,lastline=9]{ch2/ex2.18.scm}

Somewhat atypically, this was much easier (for me, at least) to define as an
iterative process than as a recursive process. The iterative process builds the
result up from the end using \texttt{cons}. The only recursive implementation
that I came up with starts from the beginning of the resulting list, so it
needs to traverse the entire list that it already built on every recursive
invocation, which I did using the previously defined \texttt{append} procedure.

\section{Exercise 2.19}
\begin{quote}
    [Long discussion of using \texttt{cc} with multiple lists of coin
    denominations.]

    Define the procedures \texttt{first-denomination},
    \texttt{except-first-denomination} and \texttt{no-more?} in terms of
    primitive operations on list structures. Does the order of the list
    \texttt{coin-values} affect the answer produced by \texttt{cc}? Why or why
    not?
\end{quote}

\lstinputlisting[firstline=20,lastline=27]{ch2/ex2.19.scm}

The order of \texttt{coin-values} does not affect the answer produced. It just
affects the order in which the possible combinations are explored. At each level
of the recursion, there are still a branch in which one coin is excluded and a
branch in which the amount to be matched is decreased by the value of the
current coin. As long as the recursion continues to the full depth in which all
coins have been considered, all possible combinations will be explored and
evaluated.

\section{Exercise 2.20}
\begin{quote}
    \ldots[W]rite a procedure \texttt{same-parity} that takes one or more
    integers and returns a list of all the arguments that have the same
    even-odd parity as the first argument. For example,
    \begin{lstlisting}
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)

(same-parity 2 3 4 5 6 7)
(2 4 6)
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=3,lastline=19]{ch2/ex2.20.scm}

This produces a recursive process, whereas I'd prefer an iterative one.
However, it allows the resulting list to be built up one element at a time
without traversing to the end to add each element. An iterative process that
considered successive elements of the input list, starting at the head, would
require repeated traversal of the output list to get the elements in the correct
order. This would involve a recursive component and probably more copying of
data.

\section{Exercise 2.21}
\begin{quote}
    The procedure \texttt{square-list} takes a list of numbers as argument and
    returns a list of the squares of those numbers.
    \begin{lstlisting}
(square-list (list 1 2 3 4))
(1 4 9 16)
    \end{lstlisting}
    Here are two different definitions of \texttt{square-list}. Complete both
    of them by filling in the missing expressions:
    \begin{lstlisting}
(define (square-list items)
  (if (null? items)
      nil
      (cons <??> <??>)))

(define (square-list items)
  (map <??> <??>))
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=5,lastline=9]{ch2/ex2.21.scm}
\lstinputlisting[firstline=14,lastline=16]{ch2/ex2.21.scm}

\section{Exercise 2.22}
\begin{quote}
    Louis Reasoner tries to rewrite the first \texttt{square-list} procedure of
    Exercise 2.21 so that it evolves an iterative process:
    \begin{lstlisting}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
    \end{lstlisting}
    Unfortunately, defining \texttt{square-list} this way produces the answer
    list in the reverse order of the one desired. Why?
\end{quote}

He iterates through the input list forward, that is from head to tail, but he
builds the output list from tail to head. Because of this, the head of the
input is transformed into the tail of the output, and so on.

\begin{quote}
    Louis then tries to fix his bug by interchanging the arguments to cons:
    \begin{lstlisting}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square
                     (car things))))))
  (iter items nil))
    \end{lstlisting}
This doesnâ€™t work either. Explain.
\end{quote}

This gets the output in basically the right order, but the structure is wrong. A
flat list is a sequence of pairs in which the \texttt{cdr} of each pair points
to the next pair, and the last \texttt{cdr} points to \texttt{nil}. By switching
the order of the arguments to \texttt{cons}, this code creates a pair in which
the \texttt{car} is a compound object, and the \texttt{cdr} is a bare integer.
The overall structure produced is a tree that is tited toward the left as
opposed to one tilted toward the right.

\section{Exercise 2.23}
\begin{quote}
    The procedure \texttt{for-each} is similar to \texttt{map}. It takes as
    arguments a procedure and a list of elements. However, rather than forming
    a list of the results, \texttt{for-each} just applies the procedure to each
    of the elements in turn, from left to right. The values returned by
    applying the procedure to the elements are not used at all ---
    \texttt{for-each} is used with procedures that perform an action, such as
    printing. The value returned by the call to \texttt{for-each} (not
    illustrated above) can be something arbitrary, such as \texttt{true}. Give
    an implementation of \texttt{for-each}.
\end{quote}

\lstinputlisting[firstline=3,lastline=9]{ch2/ex2.23.scm}

\section{Exercise 2.24}
\begin{quote}
    Suppose we evaluate the expression \texttt{(list 1 (list 2 (list 3 4)))}.
    Give the result printed by the interpreter, the corresponding
    box-and-pointer structure, and the interpretation of this as a tree (as in
    Figure 2.6).
\end{quote}

The interpreter gives the result
\begin{lstlisting}
(1 (2 (3 4)))
\end{lstlisting}

\begin{tikzpicture}[
        box/.style={rectangle, draw=black, thick, minimum size=5mm},
        % Found at http://tex.stackexchange.com/a/269410
        ptr/.style={{Circle[black, length=4pt]}-Latex,shorten <= -2pt}]
    % Nodes
    \node[box] (car1)                     { }; % (1
    \node[box] (cdr1) [right=0cm of car1] { };
    \node[box] (val1) [below=of car1]     {1};
    \node[box] (car2) [right=of cdr1]     { }; %    (2
    \node[box] (cdr2) [right=0cm of car2] { };
    \node[box] (val2) [below=of car2]     {2};
    \node[box] (car3) [right=of cdr2]     { }; %       (3
    \node[box] (cdr3) [right=0cm of car3] { };
    \node[box] (val3) [below=of car3]     {3};
    \node[box] (car4) [right=of cdr3]     { }; %           4)))
    \node[box] (cdr4) [right=0cm of car4] {/};
    \node[box] (val4) [below=of car4]     {4};

    % Lines
    \draw[ptr] (car1.center) -- (val1.north); % (1
    \draw[ptr] (cdr1.center) -- (car2.west);
    \draw[ptr] (car2.center) -- (val2.north); %    (2
    \draw[ptr] (cdr2.center) -- (car3.west);
    \draw[ptr] (car3.center) -- (val3.north); %       (3
    \draw[ptr] (cdr3.center) -- (car4.west);
    \draw[ptr] (car4.center) -- (val4.north); %          4)))
\end{tikzpicture}

\begin{allintypewriter}

\Tree [.{(1 (2 (3 4)))}
    1
    [.{(2 (3 4))}
        2
        [.{(3 4)}
            3
            4 ]]]

\end{allintypewriter}

\section{Exercise 2.25}
\begin{quote}
    Give combinations of \texttt{cars} and \texttt{cdrs} that will pick 7 from
    each of the following lists:

    \begin{lstlisting}
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
    \end{lstlisting}
\end{quote}

\begin{enumerate}
    \item The sequence is \texttt{cdr, cdr, car, cdr, car}, i.e.
        \begin{lstlisting}
(car (cdr (car (cdr (cdr x )))))
        \end{lstlisting}
        \texttt{cdr} produces a pair, so the final \texttt{car} is necessary to
        remove the \texttt{7} from \texttt{(7)}.
    \item \texttt{(car (car x))}
    \item Each \texttt{cdr} produces a pair, of which the first element is
        another list, so \texttt{car} must be used to access that list directly.
        There are six layers of nested lists, so there need to be 6
        \texttt{cdr}/\texttt{car} pairs.
        \begin{lstlisting}
(car (cdr
    (car (cdr
        (car (cdr
            (car (cdr
                (car (cdr
                    (car (cdr x))))))))))))
        \end{lstlisting}
\end{enumerate}

\section{Exercise 2.26}
\begin{quote}
	Suppose we define x and y to be two lists:
    \begin{lstlisting}
(define x (list 1 2 3))
(define y (list 4 5 6))
    \end{lstlisting}
	What result is printed by the interpreter in response to evaluating each of
	the following expressions:
    \begin{lstlisting}
(append x y)
(cons x y)
(list x y)
    \end{lstlisting}
\end{quote}

\begin{enumerate}
    \item \texttt{append} concatenates two lists; the result is a list:
        \texttt{(1 2 3 4 5 6)}.
    \item \texttt{cons} constructs a pair out of its arguments, effectively
        prepending the first argument to the sceond argument if the second
        argument is a list: \texttt{((1 2 3) 4 5 6)}.
    \item \texttt{list} constructs a list in which each argument is a single
        element: \texttt{((1 2 3) (4 5 6))}.
\end{enumerate}

\section{Exercise 2.27}
\begin{quote}
    Modify your reverse procedure of Exercise 2.18 to produce a
    \texttt{deep-reverse} procedure that takes a list as argument and returns
    as its value the list with its elements reversed and with all sublists
    deep-reversed as well. For example,
    \begin{lstlisting}
(define x
  (list (list 1 2) (list 3 4)))

x
((1 2) (3 4))

(reverse x)
((3 4) (1 2))

(deep-reverse x)
((4 3) (2 1))
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=3,lastline=13]{ch2/ex2.27.scm}

\section{Exercise 2.28}
\begin{quote}
    Write a procedure \texttt{fringe} that takes as argument a tree
    (represented as a list) and returns a list whose elements are all the
    leaves of the tree arranged in left-to-right order. For example,
    \begin{lstlisting}
(define x
  (list (list 1 2) (list 3 4)))

(fringe x)
(1 2 3 4)

(fringe (list x x))
(1 2 3 4 1 2 3 4)
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=3,lastline=16]{ch2/ex2.28.scm}

\section{Exercise 2.29}
\begin{quote}
	[Long explanation of binary mobiles.]

    \begin{enumerate}
        \item Write the corresponding selectors \texttt{left-branch} and
            \texttt{right-branch}, which return the branches of a mobile, and
            \texttt{branch-length} and \texttt{branch-structure}, which return
            the components of a branch.
        \item Using your selectors, define a procedure \texttt{total-weight}
            that returns the total weight of a mobile.
        \item A mobile is said to be \emph{balanced} if the torque applied by
            its top-left branch is equal to that applied by its top-right
            branch (that is, if the length of the left rod multiplied by the
            weight hanging from that rod is equal to the corresponding product
            for the right side) and if each of the submobiles hanging off its
            branches is balanced. Design a predicate that tests whether a
            binary mobile is balanced.
        \item Suppose we change the representation of mobiles so that the
            constructors are
            \begin{lstlisting}
(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))
            \end{lstlisting}
            How much do you need to change your programs to convert to the new
            representation?
    \end{enumerate}
\end{quote}

\begin{enumerate}
    \item \lstinputlisting[firstline=11,lastline=21]{ch2/ex2.29.scm}

    \item \lstinputlisting[firstline=40,lastline=52]{ch2/ex2.29.scm}

    \item \lstinputlisting[firstline=75,lastline=87]{ch2/ex2.29.scm}

    \item The preceding functions are written in terms of \texttt{make-mobile}
        and \texttt{make-branch}. They do not need to be changed at all if the
        underlying representation of mobiles or branches changes. One assumption
        I do make about the representation is that a mobile consisting of just
        one weight is represented using a bare numeric value.
\end{enumerate}

\end{document}
