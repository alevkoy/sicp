\documentclass{article}
\author{Abraham Levkoy}
\title{SICP exercises, section 2.4}

\usepackage{mystyle}

\begin{document}
\maketitle

\section{Exercise 2.73}
\begin{quote}
    2.3.2 described a program that performs symbolic differentiation:

    \begin{lstlisting}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product
            (multiplier exp)
            (deriv (multiplicand exp) var))
           (make-product
            (deriv (multiplier exp) var)
            (multiplicand exp))))
        ⟨more rules can be added here⟩
        (else (error "unknown expression type:
                      DERIV" exp))))
    \end{lstlisting}

    We can regard this program as performing a dispatch on the type of the
    expression to be differentiated. In this situation the ``type tag'' of the
    datum is the algebraic operator symbol (such as \texttt{+}) and the
    operation being performed is \texttt{deriv}. We can transform this program
    into data-directed style by rewriting the basic derivative procedure as

    \begin{lstlisting}
(define (deriv exp var)
   (cond ((number? exp) 0)
         ((variable? exp)
           (if (same-variable? exp var)
               1
               0))
         (else ((get 'deriv (operator exp))
                (operands exp)
                var))))

(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
    \end{lstlisting}

    \begin{enumerate}
        \item Explain what was done above. Why can’t we assimilate the
            predicates \texttt{number?} and \texttt{variable?} into the
            data-directed dispatch?
        \item Write the procedures for derivatives of sums and products, and
            the auxiliary code required to install them in the table used by
            the program above.
        \item Choose any additional differentiation rule that you like, such as
            the one for exponents (Exercise 2.56), and install it in this
            data-directed system.
        \item In this simple algebraic manipulator the type of an expression is
            the algebraic operator that binds it together. Suppose, however, we
            indexed the procedures in the opposite way, so that the dispatch
            line in \texttt{deriv} looked like

            \begin{lstlisting}
((get (operator exp) 'deriv)
 (operands exp) var)
            \end{lstlisting}

            What corresponding changes to the derivative system are required?
    \end{enumerate}
\end{quote}

\begin{enumerate}
    \item The data-directed version above dispatches on the operator of the
        expression. Expressions for which \texttt{number?} or \texttt{variable?}
        return true don't have operators.
    \item \texttt{deriv} package for sums and products:
        \lstinputlisting[firstline=66,lastline=109]{ch2/ex2.73.scm}
    \item \texttt{deriv} package for exponentiations:
        \lstinputlisting[firstline=129,lastline=154]{ch2/ex2.73.scm}
    \item If the order of the type and operation in the \texttt{get} calls were
        changed, the only corresponding change necessary would be a similar
        transposition in the \texttt{put} calls in the implementations of
        \texttt{deriv} for each type of expression.
\end{enumerate}

\end{document}
