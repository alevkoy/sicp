\documentclass{article}
\author{Abraham Levkoy}
\title{SICP exercises, section 1.2}

\usepackage{mystyle}

\begin{document}
\maketitle

\section{Exercise 1.29}
\begin{quote}
    Simpson's Rule is a more accurate method of numerical integration than the
    method illustrated above. Using Simpson's Rule, the integral of a function
    $f$ between $a$ and $b$ is approximated as
    \begin{equation*}
        \frac{h}{3}(y_0+4y_1+2y_2+4y_3+2y_4+\cdots+2y_{n-2}+4y_{n-1}+y_n),
    \end{equation*}
    where $h=(b−a)/n$, for some even integer $n$, and $y_k=f(a+kh)$.
    (Increasing $n$ increases the accuracy of the approximation.) Define a
    procedure that takes as arguments $f$, $a$, $b$, and $n$ and returns the
    value of the integral, computed using Simpson’s Rule. Use your procedure to
    integrate \texttt{cube} between 0 and 1 (with $n=100$ and $n=1000$), and
    compare the results to those of the \texttt{integral} procedure shown
    above.
\end{quote}

\lstinputlisting[firstline=4,lastline=26]{ch1/ex1.29.scm}

\begin{lstlisting}
> (integral cube 0 1 .01)
.24998750000000042
> (simpson cube 0 1 100)
.25
> (integral cube 0 1 .001)
.2467166666666667
> (simpson cube 0 1 1000)
.25
\end{lstlisting}

\texttt{simpson} finds the exact value of the integral ($\frac{1}{4}$) and is
thus more accurate than \texttt{integral}. In fact, it is spookily accurate. It
seems to produce results using only 2 intervals that are as accurate as
\texttt{integral} with 100 intervals.

\section{Exercise 1.30}
\begin{quote}
    The \texttt{sum} procedure above generates a linear recursion. The
    procedure can be rewritten so that the sum is performed iteratively. Show
    how to do this by filling in the missing expressions in the following
    definition:
    \begin{lstlisting}
(define (sum term a next b)
  (define (iter a result)
    (if <??>
        <??>
        (iter <??> <??>)))
  (iter <??> <??>))
    \end{lstlisting}
\end{quote}

\lstinputlisting[firstline=5,lastline=12]{ch1/ex1.30.scm}

This implementation produces the same results as the recursive implementation
when used in \texttt{simpson}.

\section{Exercise 1.31}
\begin{quote}
    \begin{enumerate}
        \item The \texttt{sum} procedure is only the simplest of a vast number
            of similar abstractions that can be captured as higher-order
            procedures. Write an analogous procedure called \texttt{product}
            that returns the product of the values of a function at points over
            a given range. Show how to define \texttt{factorial} in terms of
            \texttt{product}. Also use \texttt{product} to compute
            approximations to $\pi$ using the formula
            \begin{equation*}
                \frac{\pi}{4}=
                \frac{2\cdot4\cdot4\cdot6\cdot6\cdot8\cdot\cdots}
                     {3\cdot3\cdot5\cdot5\cdot7\cdot7\cdot\cdots}.
            \end{equation*}
        \item If your product procedure generates a recursive process, write
            one that generates an iterative process. If it generates an
            iterative process, write one that generates a recursive process.
    \end{enumerate}
\end{quote}

\subsection{Recursive process}
\lstinputlisting[firstline=4,lastline=11]{ch1/ex1.31.scm}

\lstinputlisting[firstline=13,lastline=24]{ch1/ex1.31.scm}

\lstinputlisting[firstline=31,lastline=42]{ch1/ex1.31.scm}
This procedure counts terms in a way such that there are two terms of this
procedure for every one term of the canonical formulation of the Wallis Formula.
I suppose my procedure is half as precise as one using the canonical enumeration
of terms. No matter: I also do half as much work per term, so I can just use
twice as many terms.

\subsection{Iterative process}
\lstinputlisting[firstline=52,lastline=62]{ch1/ex1.31.scm}

\section{Exercise 1.32}
\begin{quote}
    \begin{enumerate}
        \item Show that \texttt{sum} and \texttt{product} (Exercise 1.31) are
            both special cases of a still more general notion called
            \texttt{accumulate} that combines a collection of terms, using some
            general accumulation function:
            \begin{lstlisting}
(accumulate
 combiner null-value term a next b)
            \end{lstlisting}
            \texttt{Accumulate} takes as arguments the same term and range
            specifications as \texttt{sum} and \texttt{product}, together with
            a \texttt{combiner} procedure (of two arguments) that specifies how
            the current term is to be combined with the accumulation of the
            preceding terms and a \texttt{null-value} that specifies what base
            value to use when the terms run out. Write \texttt{accumulate} and
            show how \texttt{sum} and \texttt{product} can both be defined as
            simple calls to \texttt{accumulate}.
        \item If your \texttt{accumulate} procedure generates a recursive
            process, write one that generates an iterative process. If it
            generates an iterative process, write one that generates a
            recursive process.
    \end{enumerate}
\end{quote}

\subsection{Recursive process}
\lstinputlisting[firstline=4,lastline=13]{ch1/ex1.32.scm}

\subsection{Iterative process}
\lstinputlisting[firstline=43,lastline=54]{ch1/ex1.32.scm}

\section{Exercise 1.33}
\begin{quote}
    You can obtain an even more general version of \texttt{accumulate}
    (Exercise 1.32) by introducing the notion of a filter on the terms to be
    combined. That is, combine only those terms derived from values in the
    range that satisfy a specified condition. The resulting
    \texttt{filtered-accumulate} abstraction takes the same arguments as
    \texttt{accumulate}, together with an additional predicate of one argument
    that specifies the filter. Write \texttt{filtered-accumulate} as a
    procedure. Show how to express the following using
    \texttt{filtered-accumulate}:
    \begin{enumerate}
        \item the sum of the squares of the prime numbers in the interval $a$
            to $b$ (assuming that you have a \texttt{prime?} predicate already
            written)
        \item the product of all the positive integers less than $n$ that are
            relatively prime to $n$ (i.e., all positive integers $i<n$ such that
            $\textrm{GCD}(i,n)=1)$.
    \end{enumerate}
\end{quote}

\lstinputlisting[firstline=4,lastline=21]{ch1/ex1.33.scm}

\subsection{Sum of squares of prime numbers in interval $a$ to $b$}
\lstinputlisting[firstline=44,lastline=55]{ch1/ex1.33.scm}

\subsection{Product of positive integers less than and relatively prime to $n$}
\lstinputlisting[firstline=57,lastline=70]{ch1/ex1.33.scm}

\section{Exercise 1.34}
\begin{quote}
    Suppose we define the procedure
    \begin{lstlisting}
(define (f g) (g 2))
    \end{lstlisting}
    Then we have
    \begin{lstlisting}
(f square)
4
(f (lambda (z) (* z (+ z 1))))
6
    \end{lstlisting}
    What happens if we (perversely) ask the interpreter to evaluate the
    combination \texttt{(f f)}? Explain.
\end{quote}

\texttt{(f f)} evaluates to \texttt{(f 2)}, which in turn evaluates to
\texttt{(2 2)}. \texttt{2} isn't the name of a procedure, so this produces an
interpreter error.

\section{Exercise 1.35}
\begin{quote}
    Show that the golden ratio $\phi$ (1.2.2) is a fixed point of the
    transformation $x\rightarrow1+1/x$, and use this fact to compute $\phi$ by
    means of the fixed-point procedure.
\end{quote}

\lstinputlisting[firstline=19,lastline=22]{ch1/ex1.35.scm}

\end{document}
